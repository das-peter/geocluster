<?php

/**
 * @file
 * Geocluster extension for geofield and maps.
 */

/**
 * Diameter of the Earth in kilometers.
 */
define('GEOCLUSTER_GEOHASH_LENGTH', 12);

/**
 * Implements hook_views_api().
 */
function geocluster_views_api() {
  return array(
    'api' => '3',
  );
}

/**
 * Invokes clustering after the views query has been executed.
 *
 * Implements hook_views_post_execute_query().
 */
function geocluster_views_post_execute_query(&$view) {
  if ($cluster = geocluster_get_instance($view)) {
    $cluster->cluster($view);
  };
}

function geocluster_get_instance(&$view) {
  // Check if geocluster is enabled for this view.
  $enabled = $view->display_handler->get_option('geocluster_enabled');
  if (empty($enabled)) {
    return;
  }
  // Get geocluster options.
  $geocluster_options = $view->display_handler->get_option('geocluster_options');
  $cluster_distance = $geocluster_options['cluster_distance'];
  $field_name = $geocluster_options['cluster_field'];
  if (empty($view->field[$field_name])) {
    return;
  }
  $cluster_field = $view->field[$field_name];

  // Default zoom
  $zoom = 7;
  switch ($view->style_plugin->plugin_name) {
    case 'leaflet':
      $map = $view->style_plugin->options['map'];
      $info =  leaflet_map_get_info($map);
      $zoom = $info['settings']['zoom'];
      break;
    case 'views_geojson':
      break;
    case 'geofield_map':
      $style_options = $view->display_handler->display->display_options['style_options'];
      $zoom = $style_options['geofield_map_zoom'];
  }

  // Allow to override using get paramters.
  $zoom = isset($_GET['zoom']) ? $_GET['zoom'] : $zoom;
  $cluster_distance = isset($_GET['cluster_distance']) ? $_GET['cluster_distance'] : $cluster_distance;
  $cluster = new Geocluster($cluster_distance, $zoom, $cluster_field);
  return $cluster;
}

/**
 * Adds geocluster information to a leaflet data item.
 *
 * Implements hook_leaflet_views_alter_points_data().
 */
function geocluster_leaflet_views_alter_points_data($result, &$points) {
  if (isset($result->clustered)) {
    // Add cluster info to every points data entry.
    array_walk($points, function(&$point, $key, $count) {
      $point['clustered'] = TRUE;
      $point['cluster_items'] = $count;
    }, count($result->ids));
  }
}

/**
 * Adds geocluster information to a views_geojson result.
 *
 * Implements hook_views_geojson_render_fields_alter().
 */
function geocluster_views_geojson_render_fields_alter(&$feature, $view, $row, $index) {
  if (!empty($row->clustered)) {
    geocluster_add_geojson_cluster_info($feature, count($row->ids));
  }
}

function geocluster_add_geojson_cluster_info(&$feature, $cluster_items) {
  $feature['clustered'] = TRUE;
  $feature['cluster_items'] = $cluster_items;
}

/**
 * Implements theme_preprocess_leaflet_map().
 */
function geocluster_preprocess_leaflet_map($variables) {
  drupal_add_js(
    drupal_get_path('module', 'geocluster') . '/js/geocluster.leaflet.marker.js',
    // Add our script after leaflet.drupal.js.
    array('weight' => 5)
  );

  drupal_add_js(
    drupal_get_path('module', 'geocluster') . '/js/geocluster.leaflet.js',
    // Add our script after leaflet.drupal.js.
    array('weight' => 5)
  );
}

/**
 * Add geohash property for all geofields.
 *
 * Implements hook_entity_property_info_alter().
 */
function geocluster_entity_property_info_alter(&$info) {
  foreach ($info as &$entity_type) {
    geocluster_add_geohash_property($entity_type);
    if (isset($entity_type['bundles'])) {
      foreach ($entity_type['bundles'] as &$bundle) {
        geocluster_add_geohash_property($bundle);
      }
    }
  }
}

/**
 * Helper function that adds geohash property for a geofield.
 */
function geocluster_add_geohash_property(&$value) {
  if (isset($value['properties'])) {
    foreach ($value['properties'] as &$property) {
      if (isset($property['type']) && $property['type'] == 'geofield') {
        $property['property info']['geohash'] = array(
          'label' => t('Geohash'),
          'type' => 'string',
          'description' => t('Returns the location as geohash'),
          'getter callback' => 'geocluster_geohash_property_get_callback',
          'computed' => TRUE,
        );

        for ($i = GEOCLUSTER_GEOHASH_LENGTH; $i > 0; $i--) {
          $property['property info']['geocluster_index_' . $i] = array(
            'label' => t('Geocluster index ' . $i),
            'type' => 'string',
            'description' => t('Returns the location as geohash with length ' . $i),
            'getter callback' => 'geocluster_index_property_get_callback',
            'geohash length' => $i,
            'computed' => TRUE,
          );
        }
      }
    }
  }
}

function geocluster_get_geohash($geom) {
  geophp_load();
  $geometry = geoPHP::load($geom);
  return $geometry->out('geohash');
}

function geocluster_get_geohash_prefix($geohash, $length) {
  return $length . '_' . substr($geohash, 0, min($length, strlen($geohash)));
}

/**
 * Getter callback for a geofield geohash property.
 */
function geocluster_geohash_property_get_callback($entity, array $options, $name, $type, $info) {
  return geocluster_get_geohash($entity['geom']);
}

/**
 * Returns geohash prefixes numbered by length.
 *
 * see http://stackoverflow.com/questions/11319465/geoclusters-in-solr/11321723#11321723
 *
 * example:
 *   1_u
 *   2_u2
 *   3_u2s
 *   ...
 */
function geocluster_index_property_get_callback($entity, array $options, $name, $type, $info) {
  $geohash = geocluster_geohash_property_get_callback($entity, $options, $name, $type, $info);
  // Output an specifc geohash prefix by the specified length.
  if (isset($info['geohash length'])) {
    $length = min($info['geohash length'], strlen($geohash));
    return  geocluster_get_geohash_prefix($geohash, $length);
  }
  // No length specified.
  // Output an array of all geohash prefixed numbered by their length.
  $geohash_index = array();
  for ($i = strlen($geohash); $i > 0; $i--) {
    $geohash_index[] = geocluster_get_geohash_prefix($geohash, $i);
  }
  return $geohash_index;
}

function geocluster_field_attach_presave($entity_type, $entity) {
  // Add geohash information for columns we have added.
  $field_info = field_info_field_by_ids();
  foreach (field_info_instances($entity_type, $entity->type) as $name => $field_info_instance) {
    if ('geofield' === $field_info[$field_info_instance['field_id']]['type']) {
      $field = &$entity->{$name}[LANGUAGE_NONE][0];
      $geohash = geocluster_get_geohash($field['geom']);

      // Add data for standard geohash column.
      $field['geohash'] = $geohash;

      // Add data for geohash prefix columns.
      for ($i = GEOCLUSTER_GEOHASH_LENGTH; $i > 0; $i--) {
        $field['geocluster_index_' . $i] = geocluster_get_geohash_prefix($geohash, $i);
      }
    }
  }
}

/**
 * Implements hook_field_schema_alter().
 */
function geocluster_field_schema_alter(&$schema, $field) {
  if ($field['type'] == 'geofield') {
    // Add an addtional column of data.
    $schema['columns']['geohash'] = array(
      'description' => "Geohash.",
      'type' => 'varchar',
      'length' => 128,
      'not null' => FALSE,
    );
    // Add an additional index.
    $schema['indexes']['fid_geohash'] = array('fid', 'geohash');

    for ($i = GEOCLUSTER_GEOHASH_LENGTH; $i > 0; $i--) {
      $name = 'geocluster_index_' . $i;
      $schema['columns'][$name] = array(
        'description' => 'Geocluster index ' . $i,
        'type' => 'varchar',
        'length' => 128,  // could be $i + 3.
        'not null' => FALSE,
      );
      // Add an additional index.
      $schema['indexes']['fid_' . $name] = array('fid', $name);
    }
  }
}
